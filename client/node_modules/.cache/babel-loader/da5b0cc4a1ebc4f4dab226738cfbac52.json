{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MessageStream = require('./message_stream');\n\nconst MongoError = require('../core/error').MongoError;\n\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\n\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nconst CommandResult = require('../core/connection/command_result');\n\nconst StreamDescription = require('./stream_description').StreamDescription;\n\nconst wp = require('../core/wireprotocol');\n\nconst apm = require('../core/connection/apm');\n\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst now = require('../utils').now;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`)));\n      this[kQueue].clear();\n      this.emit('close');\n    });\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n        beforeHandshake: this[kIsMaster] == null\n      })));\n      this[kQueue].clear();\n      this.emit('close');\n    }); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  } // Wire protocol methods\n\n\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n} /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: () => true\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = now();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));\n        } else {\n          this.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};","map":{"version":3,"sources":["/Users/steve/Desktop/care/node_modules/mongodb/lib/cmap/connection.js"],"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoNetworkTimeoutError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","now","calculateDurationInMs","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","constructor","stream","options","id","address","streamIdentifier","bson","socketTimeout","monitorCommands","closed","destroyed","generation","autoEncrypter","Map","on","messageHandler","forEach","op","cb","clear","emit","destroy","beforeHandshake","pipe","description","ismaster","response","receiveResponse","idleTime","clusterTime","markAvailable","callback","Object","assign","force","end","err","command","ns","cmd","makeServerTrampoline","query","cursorState","getMore","batchSize","killCursors","insert","ops","update","remove","connection","server","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","remoteAddress","remotePort","toString","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","reply","CommandFailedEvent","result","CommandSucceededEvent","writeCommand","e","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\nconst now = require('../utils').now;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 360000;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this[kIsMaster] == null\n          })\n        )\n      );\n\n      this[kQueue].clear();\n      this.emit('close');\n    });\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"]},"metadata":{},"sourceType":"script"}